<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Monster Hunter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Basic styling */
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        /* HUD Styling */
        #hud {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 15px; /* Rounded corners */
            font-size: 1.2em;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); /* Shadow */
        }
        /* Start Button Styling */
        #startButton {
            position: fixed;
            bottom: 30px; /* Positioned lower */
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            padding: 15px 30px; /* Larger padding */
            font-size: 1.1em; /* Slightly larger font */
            font-weight: bold; /* Bold text */
            color: white;
            background: linear-gradient(145deg, #4f46e5, #7c3aed); /* Gradient background */
            border: none;
            border-radius: 30px; /* More rounded */
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); /* More pronounced shadow */
            transition: all 0.3s ease; /* Smooth transition */
        }
        #startButton:hover {
            background: linear-gradient(145deg, #4338ca, #6d28d9); /* Darker gradient on hover */
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4); /* Larger shadow on hover */
            transform: translateX(-50%) scale(1.05); /* Slight scale effect */
        }
        #startButton:active {
            transform: translateX(-50%) scale(0.98); /* Press effect */
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }
        /* Message Box Styling */
        #messageBox {
            position: fixed;
            bottom: 90px; /* Position above start button */
            left: 50%;
            transform: translateX(-50%);
            z-index: 11; /* Above HUD and button */
            background-color: rgba(255, 255, 0, 0.8); /* Yellow background */
            color: black;
            padding: 8px 15px;
            border-radius: 10px;
            font-size: 0.9em;
            display: none; /* Hidden by default */
            text-align: center;
            max-width: 80%;
        }
    </style>
</head>
<body>
    <div id="hud">Power: <span id="powerLevel">10</span></div>

    <button id="startButton">Start AR Hunt</button>

    <div id="messageBox"></div>

    <script>
        // --- Global Variables ---
        let container;
        let camera, scene, renderer;
        let xrSession = null;
        let xrRefSpace = null;
        let gl = null; // WebGL rendering context

        let playerPower = 10;
        const monsters = []; // Array to hold monster objects { mesh, power }
        const MONSTER_SPAWN_RADIUS = 15; // Spawn monsters within 15 meters
        const MONSTER_DESPAWN_RADIUS = 25; // Despawn if further than 25 meters
        const INTERACTION_DISTANCE_WEAK = 1.5; // Distance to interact with weak monsters (meters)
        const INTERACTION_DISTANCE_STRONG = 3.0; // Distance strong monsters start affecting player
        const POWER_DRAIN_RATE = 0.1; // Power drained per second by nearby strong monsters
        const MAX_MONSTERS = 10; // Max monsters active at once
        let lastFrameTime = 0;

        const hudPowerLevel = document.getElementById('powerLevel');
        const startButton = document.getElementById('startButton');
        const messageBox = document.getElementById('messageBox');

        // --- Initialization ---
        function init() {
            // Basic three.js scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Renderer will be setup after XR session starts

            // Add ambient light
            const light = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(light);
            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);


            // Check for WebXR support
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-ar')
                    .then((supported) => {
                        if (supported) {
                            startButton.textContent = "Start AR Hunt";
                            startButton.onclick = startARSession;
                        } else {
                            showMessage("AR Not Supported on this device/browser.");
                            startButton.disabled = true;
                        }
                    })
                    .catch((err) => {
                         console.error("Error checking XR support:", err);
                         showMessage("Error checking AR support.");
                         startButton.disabled = true;
                    });
            } else {
                showMessage("WebXR API Not Available.");
                startButton.disabled = true;
            }

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            // Initial HUD update
            updateHUD();
        }

        // --- WebXR Session Management ---
        function startARSession() {
            navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['local-floor'], // Track relative to the floor
                // optionalFeatures: ['hit-test', 'dom-overlay'], // Could add hit-test later for better placement
            }).then(onSessionStarted)
              .catch((err) => {
                  console.error("Failed to start AR session:", err);
                  showMessage(`Failed to start AR: ${err.message}. Ensure permissions are granted.`);
              });
        }

        function onSessionStarted(session) {
            xrSession = session;
            startButton.style.display = 'none'; // Hide start button
            showMessage("AR Session Started! Look around for monsters.");
            setTimeout(() => { messageBox.style.display = 'none'; }, 3000); // Hide message after 3s

            // Create WebGL context compatible with XR
            const canvas = document.createElement('canvas');
            document.body.appendChild(canvas);
            gl = canvas.getContext('webgl', { xrCompatible: true });

            // Setup three.js renderer with XR
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                context: gl,
                alpha: true, // Transparent background
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.xr.setReferenceSpaceType('local-floor'); // Use floor-relative tracking
            renderer.xr.setSession(xrSession);

            // Get reference space
            session.requestReferenceSpace('local-floor').then((refSpace) => {
                xrRefSpace = refSpace;
                // Start the render loop
                renderer.setAnimationLoop(renderLoop);
                // Spawn initial monsters
                spawnInitialMonsters();
            }).catch(err => {
                console.error("Could not get reference space:", err);
                showMessage("Error setting up AR tracking space.");
                session.end();
            });

            // Handle session end
            session.addEventListener('end', onSessionEnded);
        }

        function onSessionEnded() {
            xrSession = null;
            renderer.setAnimationLoop(null); // Stop render loop
            if (renderer && renderer.domElement.parentNode) {
                renderer.domElement.parentNode.removeChild(renderer.domElement);
            }
            renderer = null;
            gl = null;
            startButton.style.display = 'block'; // Show start button again
            startButton.textContent = "Restart AR Hunt";
            monsters.forEach(m => scene.remove(m.mesh)); // Clear monsters from scene
            monsters.length = 0; // Clear monsters array
            showMessage("AR Session Ended.");
        }

        // --- Rendering Loop ---
        function renderLoop(timestamp, frame) {
            if (!renderer || !xrSession) return;

            const deltaTime = (timestamp - lastFrameTime) / 1000; // Time delta in seconds
            lastFrameTime = timestamp;

            if (frame) {
                const viewerPose = frame.getViewerPose(xrRefSpace);
                if (viewerPose) {
                    // Update camera position based on user movement
                    const pos = viewerPose.transform.position;
                    camera.position.set(pos.x, pos.y, pos.z); // Update three.js camera position

                    // Game Logic Updates
                    updateMonsters(camera.position, deltaTime);
                    checkCollisions(camera.position, deltaTime);
                    manageMonsterPopulation(camera.position);
                }
                // Renderer handles drawing the scene based on XR pose
                renderer.render(scene, camera);
            } else {
                 // Fallback or non-XR rendering if needed (not implemented here)
                 console.log("No XRFrame available");
            }
        }

        // --- Game Logic ---

        function spawnMonster(position) {
            if (monsters.length >= MAX_MONSTERS) return;

            // Calculate power level relative to player
            const powerVariance = playerPower * 0.30;
            const monsterPower = Math.max(1, Math.floor(playerPower - powerVariance + Math.random() * powerVariance * 2));

            // Determine color based on power
            const color = monsterPower < playerPower ? 0x00ff00 : 0xff0000; // Green if weaker, Red if stronger/equal

            // Random size
            const diameter = 1 + Math.random() * 3; // 1' to 4' diameter (approx 0.3m to 1.2m)
            const radius = diameter * 0.1524; // Convert feet to meters for radius

            // Create sphere geometry and material
            const geometry = new THREE.SphereGeometry(radius, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.5,
                metalness: 0.3,
                transparent: true,
                opacity: 0.9
            });
            const sphereMesh = new THREE.Mesh(geometry, material);

            // Position the monster
            sphereMesh.position.copy(position);
            sphereMesh.position.y = 1.2; // Float ~4 feet (1.2m) off the ground (local-floor origin)

            // Add to scene and tracking array
            scene.add(sphereMesh);
            monsters.push({ mesh: sphereMesh, power: monsterPower });
            // console.log(`Spawned monster (Power: ${monsterPower}) at`, sphereMesh.position);
        }

        function spawnInitialMonsters() {
             // Spawn a few monsters to start
             for (let i = 0; i < Math.min(5, MAX_MONSTERS); i++) {
                 spawnMonsterAroundPlayer(camera.position, MONSTER_SPAWN_RADIUS / 2); // Spawn closer initially
             }
        }

        function spawnMonsterAroundPlayer(playerPosition, radius) {
            const angle = Math.random() * Math.PI * 2;
            const dist = radius * 0.5 + Math.random() * radius * 0.5; // Spawn between radius/2 and radius
            const spawnPos = new THREE.Vector3(
                playerPosition.x + Math.cos(angle) * dist,
                playerPosition.y, // Keep Y at player level initially, will be adjusted
                playerPosition.z + Math.sin(angle) * dist
            );
            spawnMonster(spawnPos);
        }


        function updateMonsters(playerPosition, deltaTime) {
            // Simple monster behavior (e.g., slight floating movement)
            monsters.forEach(monster => {
                // Optional: Add subtle floating animation
                monster.mesh.position.y += Math.sin(lastFrameTime / 500 + monster.mesh.uuid.charCodeAt(0)) * 0.001; // Slow bobbing
            });
        }

        function checkCollisions(playerPosition, deltaTime) {
            const monstersToRemove = [];

            monsters.forEach((monster, index) => {
                const distance = playerPosition.distanceTo(monster.mesh.position);

                if (monster.power < playerPower) {
                    // Weaker monster - check for capture/attack
                    if (distance < INTERACTION_DISTANCE_WEAK) {
                        // Player "walked through" a weaker monster
                        console.log(`Captured weak monster! Power: ${monster.power}`);
                        playerPower += Math.max(1, Math.floor(monster.power / 5)); // Increase player power proportionally
                        updateHUD();
                        monstersToRemove.push(index);
                        scene.remove(monster.mesh);
                        // Optional: Add a visual/sound effect here
                        showMessage(`Captured Monster! +${Math.max(1, Math.floor(monster.power / 5))} Power!`);
                         setTimeout(() => { messageBox.style.display = 'none'; }, 2000);
                    }
                } else {
                    // Stronger monster - check for proximity danger
                    if (distance < INTERACTION_DISTANCE_STRONG) {
                        // Player is too close to a stronger monster
                        const powerDrain = POWER_DRAIN_RATE * deltaTime * monster.power; // Drain more based on monster power
                        playerPower = Math.max(0, playerPower - powerDrain); // Drain player power, don't go below 0
                        updateHUD();
                        // Optional: Add visual feedback (e.g., screen flash red?)
                        monster.mesh.material.color.setHex(0xff6666); // Make it pulse red slightly brighter
                        if (playerPower <= 0) {
                            // Game Over condition
                            showMessage("You ran out of power! Game Over.");
                            if(xrSession) xrSession.end(); // End the session
                        }
                    } else {
                         monster.mesh.material.color.setHex(0xff0000); // Reset color if player moves away
                    }
                }
            });

            // Remove captured monsters (iterate backwards to avoid index issues)
            for (let i = monstersToRemove.length - 1; i >= 0; i--) {
                monsters.splice(monstersToRemove[i], 1);
            }
        }

        function manageMonsterPopulation(playerPosition) {
            // Despawn monsters that are too far away
            const monstersToRemove = [];
             monsters.forEach((monster, index) => {
                const distance = playerPosition.distanceTo(monster.mesh.position);
                if (distance > MONSTER_DESPAWN_RADIUS) {
                     monstersToRemove.push(index);
                     scene.remove(monster.mesh);
                     // console.log("Despawned distant monster");
                }
             });
             // Remove them
             for (let i = monstersToRemove.length - 1; i >= 0; i--) {
                monsters.splice(monstersToRemove[i], 1);
            }


            // Spawn new monsters if below max count and randomly
            if (monsters.length < MAX_MONSTERS && Math.random() < 0.02) { // Chance to spawn new monster each frame
                spawnMonsterAroundPlayer(playerPosition, MONSTER_SPAWN_RADIUS);
            }
        }


        function updateHUD() {
            hudPowerLevel.textContent = Math.floor(playerPower);
        }

        function showMessage(msg) {
             messageBox.textContent = msg;
             messageBox.style.display = 'block';
             // Optional: Auto-hide after a few seconds unless it's a persistent error
             // setTimeout(() => { messageBox.style.display = 'none'; }, 5000);
        }

        // --- Utility Functions ---
        function onWindowResize() {
            if (renderer && xrSession) { // Only resize if renderer exists (session active)
                 camera.aspect = window.innerWidth / window.innerHeight;
                 camera.updateProjectionMatrix();
                 renderer.setSize(window.innerWidth, window.innerHeight);
            } else if (!xrSession) { // If session not active, update perspective camera directly
                 camera.aspect = window.innerWidth / window.innerHeight;
                 camera.updateProjectionMatrix();
                 // No renderer size to set yet
            }
        }

        // --- Start the app ---
        init();

    </script>
</body>
</html>

